#!/usr/bin/python

import re
import sys
import os
import glob
import time
import select
import logging
import traceback
from subprocess import *
from optparse import OptionParser

timestampbase = ".snapr"
logfilebase = ".snapr.log"
levels = [ [ "hourly",   6, "%Y.%j.%H" ],
           [ "daily",    7, "%Y.%j" ],
           [ "weekly",   4, "%Y.%U" ],
           [ "monthly", 12, "%Y.%m" ],
           [ "yearly",  10, "%Y" ] ]

prefixes = [l[0] for l in levels]

do_nothing = False
default_mode = 0755
default_max_dir = 99

logformat = "%(levelname)-1.1s %(asctime)-15s %(message)s"
dateformat = "%Y%m%d.%H%M%S"
logging.basicConfig(format=logformat, datefmt=dateformat, level=logging.ERROR)
logger = logging.getLogger('snapr')

rsyncresults = { 0: "Success",
                 1: "Syntax error",
                 2: "Protocol incompatibility",
                 3: "Selection error",
                 4: "Not supported",
                 5: "Protocol initialization error",
                 6: "Logging error",
                 10: "Socket error",
                 11: "File error",
                 12: "Protocol error",
                 13: "Diagnostics error",
                 14: "IPC error",
                 20: "Caught signal",
                 21: "Subprocess error",
                 22: "Memory allocation error",
                 23: "Partial transfer error",
                 24: "Partial transfer, file vanished",
                 25: "Limited deletions",
                 30: "Timeout in data send/receive",
                 35: "Timeout waiting for daemon connection" }

def second_timestamps(option, opt_str, value, parser):
    log("Setting second timestamps")
    for i in range(0, len(levels)):
        levels[i][2] = '%Y.%m.%d.%H.%M.%S'

def log(text):
    logger.info(text)

def trace(text):
    logger.debug(text)

def error(text):
    logger.error(text)
    if options.verbose or options.trace:
        traceback.print_exc(file=sys.stderr)
    sys.exit(1)

def mkdir(dirname):
    if do_nothing:
        log("Not making new directory: %s" % dirname)
        return
    log("Making new directory: %s" % dirname)
    try:
        os.mkdir(dirname, default_mode)
    except os.error, e:
        error("Cannot mkdir: %s" % e)

def rmtree(dirname):
    if do_nothing:
        log("Not removing directory tree: %s" % dirname)
        return
    log("Removing directory tree: %s" % dirname)
    try:
        retcode = call("rm -rf %s" % dirname, shell=True)
        if retcode < 0:
            log("Child was terminated by signal %d" % -retcode)
        else:
            log("Child returned %d" % retcode)
    except os.error, e:
        error("Removal of %s failed: %s" % (dirname, e))

def rename(old,new):
    if do_nothing:
        log("Not moving %s to %s" % (old, new))
        return
    log("Moving %s to %s" % (old, new))
    if os.path.isdir(new):
        error("Target of rename exists: %s" % new)
    try:
        os.rename(old, new)
    except os.error, e:
        error("Cannot rename: %s", e)

def get_directory_list(level):
    (level_name, level_count, level_format) = levels[level]
    dirs = []
    for i in range(0, default_max_dir):
        dirname = level_name + ".%d" % i
        if os.path.isdir(dirname):
            trace("Found %s" % dirname)
            dirs.append(dirname)
    return dirs

def remove_oldest_directory(level):
    dirs = get_directory_list(level)
    if len(dirs) < 1:
        error("No directories in list at level %d" % level)
    oldest = dirs[len(dirs) - 1]
    rmtree(oldest)

def add_timestamp(level, name):
    (level_name, level_count, level_format) = levels[level]
    timestamp = time.strftime(level_format)
    timestampfile = os.path.join(name, timestampbase)
    try:
        f = open(timestampfile, 'a')
    except IOError, e:
        error("Could not open %s: %s" % (timestampfile, e))
    except:
        error("Could not open %s: %s" % (timestampfile, sys.exc_info()[0]))
    print >>f, level_name, timestamp, time.ctime()
    f.close()

def get_timestamp(level):
    (level_name, level_count, level_format) = levels[level]
    timestampfile = os.path.join(level_name + '.0', timestampbase)
    try:
        with open(timestampfile, 'r') as f:
            for line in f.readlines():
                (name, timestamp) = (line + " unknown unknown").split()[0:2]
                log("Timestamp for %s is %s" % (name, timestamp))
                if name == level_name:
                    return timestamp
    except:
        pass
    return 'unknown'

def rename_oldest_directory(level):
    level_name = levels[level][0]
    next_level_name = levels[level+1][0]
    dirs = get_directory_list(level)
    if len(dirs) < 1:
        error("No directories in list at level %d" % level)
    oldest = dirs[len(dirs) - 1]
    rename(oldest, next_level_name + '.0')
    add_timestamp(level+1, next_level_name + '.0')

def shift_directories(level):
    level_name = levels[level][0]
    dirs = get_directory_list(level)
    if len(dirs) < 1:
        error("No directories in list at level %d" % level)
    targets = []
    for i in range(0, len(dirs)):
        target = level_name + (".%d" % (i + 1))
        trace("Using target: %s" % target)
        targets.append(target)
    # The target is either identical to dirs, or there is a free dir
    # This is order n^2, but n is small
    # This will fail if do_nothing is True
    for j in range(0, len(dirs)):
        for i in range(0, len(dirs)):
            if dirs[i] == targets[i]:
                trace("Match for target %s" % targets[i])
                continue
            if os.path.isdir(targets[i]):
                trace("Existing target %s" % targets[i])
                continue
            rename(dirs[i], targets[i])

def time_has_passed(level):
    (level_name, level_count, level_format) = levels[level]
    current_timestamp = time.strftime(level_format)
    dir_timestamp = get_timestamp(level)
    if current_timestamp == dir_timestamp:
        log("Timestamps match: %s, %s" % (current_timestamp, dir_timestamp))
        return False
    log("Timestamps do not match: %s, %s" % (current_timestamp, dir_timestamp))
    return True

def rotate_levels(level):
    (level_name, level_count, level_format) = levels[level]
    log("rot%d: start" % level)
    if level >= len(levels):
        log("rot%d: exceeds total of %d level" % (level, len(levels)))
        return
    dirs = get_directory_list(level)
    if not len(dirs):
        log("rot%d: end" % level)
        return
    if len(dirs) >= level_count:
        if level + 1 >= len(levels) or not time_has_passed(level+1):
            remove_oldest_directory(level)
        else:
            rotate_levels(level+1)
            rename_oldest_directory(level)
    shift_directories(level)
    log("rot%d: end" % level)

def get_target():
    (level_name, level_count, level_format) = levels[0]
    target = level_name + '.0'
    working = target + '.working'
    if os.path.isdir(target):
        log("Target directory exists, rotating: %s" % target)
    rotate_levels(0)
    if os.path.isdir(working):
        log("Use existing working directory: %s" % working)
    else:
        mkdir(working)
        log("Use new working directory: %s" % working)
    add_timestamp(0, working)
    return [target, working]

def store_value(option, opt_str, value, parser):
    level = parser.rargs[0]
    newval = parser.rargs[1]
    idx = None
    for i in range(0, len(levels)):
        if levels[i][0] == level:
            idx = i
    if idx == None:
        log("%s is not a valid level" % level)
        log("Valid levels are:")
        for l in levels:
            log("  %s" % l[0])
        sys.exit(0)
    else:
        levels[idx] = [level, newval]

def drain(p, outputfile = None, match = None):
    done = False

    output = None
    if outputfile:
        try:
            output = open(outputfile, 'a')
        except IOError, e:
            error("Could not open %s: %s" % (outputfile, e))
        except:
            error("Could not open %s: %s" % (outputfile, sys.exc_info()[0]))

    try:
        while not done:
            try:
                [rlist, wlist, xlist] = select.select([p.stdout, p.stderr],
                                                      [],
                                                      [p.stdout, p.stderr],
                                                      1000)
            except select.error, e:
                trace("Exception: %s" % e)
                break

            for i in rlist:
                line = i.readline()
                if len(line) and line[len(line) - 1] == '\r':
                    trace(line.strip())
                elif len(line):
                    l = line.strip()
                    if output and match and re.match(match, l):
                        l = re.sub(match, '', l).strip()
                        print >>output, l
                    else:
                        if re.match("(total|sent|LS)", l):
                            log(l)
                        else:
                            trace(l)
                else:
                    done = True
    except KeyboardInterrupt:
        pass
    p.wait()
    try:
        result = rsyncresults[p.returncode]
    except:
        result = "Unknown"
    log("Return code = %d: %s" % (p.returncode, result))

    if outputfile:
        output.close()


def flatten(nested):
    try:
        # Use idiom to detect a string and raise TypeError if found
        try:
            nested + ''
        except TypeError:
            pass
        else:
            raise TypeError

        for l in nested:
            for e in flatten(l):
                yield e
    except TypeError:
        yield nested


def intperm(perm):
    mode = 0

    if perm[0] == 'r': mode |= 00400
    if perm[1] == 'w': mode |= 00200
    if perm[2] == 'x': mode |= 00100
    if perm[2] == 's': mode |= 04100
    if perm[2] == 'S': mode |= 01000

    if perm[3] == 'r': mode |= 00040
    if perm[4] == 'w': mode |= 00020
    if perm[5] == 'x': mode |= 00010
    if perm[5] == 's': mode |= 02010
    if perm[5] == 'S': mode |= 02000

    if perm[6] == 'r': mode |= 00004
    if perm[7] == 'w': mode |= 00002
    if perm[8] == 'x': mode |= 00001
    if perm[8] == 't': mode |= 01001
    if perm[8] == 'T': mode |= 01000
    return mode


if __name__ == "__main__":
    parser = OptionParser()
    parser.add_option("-v", "--verbose", dest="verbose",
                      action="store_true", default=False,
                      help="Verbose")
    parser.add_option("-t", "--trace", dest="trace",
                      action="store_true", default=False,
                      help="Verbose")
    parser.add_option("-n", "--trial-run", dest="nothing",
                      action="store_true", default=False,
                      help="Do nothing (trial run)")
    parser.add_option("-f", "--force", dest="force",
                      action="store_true", default=False,
                      help="Force, avoiding consistency checks")
    parser.add_option("-r", "--rotate", dest="rotate",
                      action="store_true", default=False,
                      help="Rotate standard directories")
    parser.add_option("-l", "--level", nargs=2, action="callback",
                      callback=store_value, dest="level")
    parser.add_option("-d", "--dir", dest="dir",
                      help="Destination directory")
    parser.add_option("--second-timestamps", action="callback",
                      callback=second_timestamps)
    parser.add_option("--list", dest="list",
                      action="store_true", default=False)
    parser.add_option("-s", "--space-efficient", dest="space_efficient",
                      action="store_true", default=False)
    (options, args) = parser.parse_args()

    if options.nothing:
        do_nothing = True
    if options.verbose:
        logger.setLevel(logging.INFO)
    if options.trace:
        logger.setLevel(logging.DEBUG)

    if not len(args):
        parser.print_help()
        sys.exit(0)

    if options.list:
        if len(args) != 1:
            log("Nothing to list")
            parser.print_help()
            sys.exit(0)
        p = Popen(["rsync", args[0]], stdout=PIPE, stderr=PIPE, close_fds=True)
        drain(p)
        sys.exit(0)

    # cd to working directory; create if non-existent
    if options.dir:
        try:
            os.chdir(options.dir)
        except:
            try:
                os.makedirs(options.dir, default_mode)
            except os.error, e:
                error("Cannot create path to %s: %s" % (options.dir, e))
            try:
                os.chdir(options.dir)
            except os.error, e:
                error("Cannot chdir to %s: %s" % (options.dir, e))

    filelog = logging.FileHandler(os.path.join(os.getcwd(), logfilebase))
    filelog.setLevel(logging.DEBUG)
    filelog.setFormatter(logging.Formatter(logformat, dateformat))
    logger.addHandler(filelog)

    log("Current working direction is %s" % os.getcwd())

    # check working directory for stuff
    if not options.force:
        expected=0
        unexpected=0
        for filename in glob.iglob("*"):
            if not os.path.isdir(filename):
                unexpected += 1
                continue
            r = [filename \
                 for p in prefixes \
                 for m in [re.match(p, filename)] if m]
            if r:
                expected += 1
            else:
                unexpected += 1
        if unexpected > expected * 3:
            print "Analysis of %s:" % os.getcwd()
            print "  %d unexpected and %d expected files found" % (unexpected,
                                                                   expected)
            print "  This directory is probably not a snapr target"
            print "  Use -f to force use of this directory"
            sys.exit(1)

    if not len(args):
        parser.print_help()
        sys.exit(0)

    # Rotate
    [target, working] = get_target()
    trace("target=%s working=%s args[0]=%s" % (target, working, args[0]))
    if args[0][0] == '.':
        error("Backup source be an absolute path (source=%s)" % args[0])

    if options.space_efficient:
        space_efficient = [ "--no-o", "--no-g", "--no-p", "--chmod=ug=rwX" ]
    else:
        space_efficient = [ "-ogp" ]

    try:
        os.chdir(working)
    except os.error, e:
        error("Cannot chdir to %s: %s" % (working, e))
    p = Popen(list(flatten(["rsync",
                            "-rltDvv", "-n", "-ogp",
                            "--link-dest", "../hourly.1",
                            "--numeric-ids",
                            "--itemize-changes",
                            "--out-format", "LS %B %8U %8G %10l %M %n",
                            args[0], '.'])),
              stdout=PIPE, stderr=PIPE,
              close_fds=True, universal_newlines=True);
    drain(p, ".snapr.ls", "LS")
    if not do_nothing:
        p = Popen(list(flatten(["rsync",
                                "-rltDvv", "--delete", "--fuzzy",
                                space_efficient,
                                "--link-dest", "../hourly.1",
                                "--itemize-changes",
                                "--out-format", "LS %B %8U %8G %10l %M %n",
                                args[0], '.'])),
                  stdout=PIPE, stderr=PIPE,
                  close_fds=True, universal_newlines=True);
        drain(p)
        if p.returncode:
            sys.exit(0)
        if options.space_efficient:
            with open(".snapr.ls") as f:
                for line in f:
                    (perms, uid, gid, size, date, name) = \
                            re.split('\s+', line.strip(), maxsplit=5)
                    trace("%s %s %s %s" % (perms, uid, gid, name))
                    try:
                        os.chown(name, int(uid), int(gid))
                    except IOError, e:
                        log("Could not change owner to %d,%d for %s: %s"
                            % (int(uid), int(gid), name, e))
                    try:
                        os.chmod(name, intperm(perms))
                    except:
                        log("Could not mode to %o,%s for %s: %s"
                            % (intperm(perms), perms, name, e))

    os.chdir("..")

    rename(working, target)
    sys.exit(0)
